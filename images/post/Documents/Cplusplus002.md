---
title: C++封装
date: 2020-03-18 14:23:13
tags: 
---


## C++三大特性
**封装**

**继承**

**多态**

## 1 封装
* 对象: 任何具有状态和行为的实体。
* 类: 对象的集合
* 封装: 将属性和行为作为一个整体，表现世界上的事务。**万物皆对象**。将属性和行为加以**权限**控制

封装类的语法  `class 类名{访问权限: 属性/行为};`
* 实例化: 通过类创建一个具体的对象

* 权限: 类封装中有三种权限，将属性和行为放在不同的权限下，加以控制

| 权限 | 权限类别 | 访问限定|
|:--:|:--:|:--:|
| 公共权限 | public | 类内可以访问，类外可以访问 |
| 保护权限 | protected | 类内可以访问，类外不可以访问，子类可以访问父类中的保护内容|
| 私有权限(默认) | private | 类内可以访问，类外不可以访问，子类不可以访问父类中的保护内容|

* struct和class的核心区别：默认的访问权限不同，struct默认公共权限，class默认私有权限

* 将C++的成员属性设置为私有，控制成员属性的读写权限 

* 对于写权限，在setValue(int value)成员函数中，可以检测value值的有效性

* .h文件和.cpp文件, 因为作用域不同，`类名::成员函数`的形式引用成员函数

## 2 对象特性

* **对象的初始化和清理**，是很重要的安全问题

* 构造函数和析构函数: **解决对象初始化(构造)和清理(析构)的安全问题**，这两个函数会被编译器自动调用，完成对象的初始化和清理

* 如果程序员不提供构造函数和析构函数，**编译器自动提供的构造函数和析构函数是空实现**

| 构造函数 | 析构函数 |
| :--: | :--: |
| 主要用于对象创建时成员的初始化，编译器自动调用 | 对象销毁前进行清理工作，编译器自动调用 |
| public作用域 | public作用域 |
| `类名(){}` | `~类名(){}`|
| 函数名称和类名称相同 | 函数名称和类名称相同，在函数名称前加上~ |
| 无返回值 | 无返回值 |
| 可以有参数，可以重载 | 不可以有参数，不可以重载 |
| 程序在对象调用之前自动调用构造函数，只调用一次，无需手动调用 | 程序在对象销毁之前自动调用析构函数，只调用一次，无需要手动调用 |

* 构造函数的分类 1

| | 无参构造函数 | 有参构造函数 | 拷贝构造函数 |
| :--: | :--: | :--: | :--: |
|构造函数定义| **Person()** | **Person(int a)** | **Person(const Person &p)** |
|构造函数调用| `Person p1; //默认构造函数调用` | `Person p2(10);` | `Person p3(p1);` |

**注意事项: ** 默认构造函数调用不用加括号，`Person p(); //编译器会认为是函数的一种定义，而不会定义对一个对象`

* 构造函数的分类 2

|  | 括号法 | 显示法 | 隐式转换法 |
| :--: | :--: | :--: | :--: |
| 无参构造函数 | `Person p1;` | `Person p1;` | `Person p1;` |
| 有参构造函数 | `Person p2(10);` | `Person p2 = Person (10);` | `Person p2 = 10;` |
| 拷贝构造函数 | `Person p3(p2); ` | `Person p3 = Person(p2);// p2不能是拷贝构造函数` | `Person p3 = p2;// p2不能是拷贝构造函数` |

**Person(10);** 单独出现是一个匿名对象，当前行结束后，系统立马析构，回收匿名对象。

**Person(p3);**
不可以用拷贝构造函数初始化匿名对象，也就是在显示法和拷贝构造函数结合，括号内的内容不可以是拷贝构造函数。

* 拷贝构造函数的调用

1. 使用一个已经创建完毕的对象来初始化一个新的对象

2. 值传递的方式给函数传值

3. 值方式返回局部对象

```
#include <iostream>
using namespace std;

class Person
{
public:
    Person()
    {
        cout << "无参构造函数！" << endl;
    }
    Person(int m_age)
    {
        age = m_age;
        cout << "有参构造函数！" << endl;
    }

    Person(const Person &p)
    {
        age = p.age;
        cout << "拷贝构造函数！" << endl;
    }
    ~Person()
    {
        cout << "析构函数！" << endl;
    }

    int getAge()
    {
        return age;
    }

private:
    int age;
};

// 1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
    Person p1 = Person(10);
    Person p2 = Person(p1);
    cout << "P2的年龄！" << p2.getAge() << endl;
}

void doWork(Person p)
{
}
// 2. 值传递的方式给函数传值
void test02()
{
    // 调用有参构造函数
    Person p1 = Person(10);
    cout << "P2的年龄！" << p1.getAge() << endl;
    // 调用拷贝构造函数，但是拷贝的是临时的副本，在doWork中修改并不会改变p1的值
    doWork(p1);
}

// 3. 值方式返回局部对象

Person doWork2()
{
    // 新建一个局部对象
    Person p;
    cout << "-----" << endl;
    // 拷贝p1后返回，而不是直接将p返回
    return p;
}

void test03()
{
    Person p1 = doWork2();
}

int main()
{
    test01();
    test02();
    test03();
    system("pause");
    return 0;
}
```

**编译器默认添加三种构造函数**
 
 默认构造函数(无参，函数体为空)

 默认析构函数(无参，函数体为空)

 默认拷贝构造函数(对属性进行值拷贝)

 **构造函数调用规则**

 * 用户定义有参构造函数，则系统不提供无参构造函数，但提供拷贝构造函数。
 `Person p; // Person 类中如果不定义无参构造函数，则这句话会报错`

 * 用户定义拷贝构造函数，则系统不提供无参，也不提供有参构造函数
 `Person p; Person p(20); // Person 类中如果不定义无参和有参构造函数，则这两句话会报错`























